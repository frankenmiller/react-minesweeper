{"ast":null,"code":"import { MAX_ROWS, MAX_COLS, NO_OF_BOMBS } from \"../constants\";\nimport { CellValue, CellState } from \"../types\";\nexport const generateCells = () => {\n  let cells = [];\n\n  // generating all cells\n  for (let row = 0; row < MAX_ROWS; row++) {\n    cells.push([]);\n    for (let col = 0; col < MAX_COLS; col++) {\n      cells[row].push({\n        value: CellValue.none,\n        state: CellState.open\n      });\n    }\n  }\n\n  // randomly put 10 bombs\n  let bombsPlaced = 0;\n  while (bombsPlaced < NO_OF_BOMBS) {\n    const randomRow = Math.floor(Math.random() * MAX_ROWS);\n    const randomCol = Math.floor(Math.random() * MAX_COLS);\n    const currentCell = cells[randomRow][randomCol];\n    if (currentCell.value !== CellValue.bomb) {\n      cells = cells.map((row, rowIndex) => row.map((cell, colIndex) => {\n        if (randomRow === rowIndex && randomCol === colIndex) {\n          return {\n            ...cell,\n            value: CellValue.bomb\n          };\n        }\n        return cell;\n      }));\n      bombsPlaced++;\n    } // if statement\n  } // while loop\n\n  // calculate the numerals that correspons with cells adjacent to bombs\n  for (let rowIndex = 0; rowIndex < MAX_ROWS; rowIndex++) {\n    for (let colIndex = 0; colIndex < MAX_COLS; colIndex++) {\n      const currentCell = cells[rowIndex][colIndex];\n      if (currentCell.value === CellValue.bomb) {\n        continue;\n      }\n      let numberOfBombs = 0;\n      const topLeftBomb = rowIndex > 0 && colIndex > 0 ? cells[rowIndex - 1][colIndex - 1] : null;\n      const topBomb = rowIndex > 0 ? cells[rowIndex - 1][colIndex] : null;\n      const topRightBomb = rowIndex > 0 && colIndex < MAX_COLS - 1 ? cells[rowIndex - 1][colIndex + 1] : null;\n      const leftBomb = colIndex > 0 ? cells[rowIndex][colIndex - 1] : null;\n      const rightBomb = colIndex < MAX_COLS - 1 ? cells[rowIndex][colIndex + 1] : null;\n      const bottomLeftBomb = rowIndex < MAX_ROWS - 1 && colIndex > 0 ? cells[rowIndex + 1][colIndex - 1] : null;\n      const bottomBomb = rowIndex < MAX_ROWS - 1 ? cells[rowIndex + 1][colIndex] : null;\n      const bottomRightBomb = rowIndex < MAX_ROWS - 1 && colIndex < MAX_COLS - 1 ? cells[rowIndex + 1][colIndex + 1] : null;\n      if (topLeftBomb && topLeftBomb.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (topBomb && topBomb.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (topRightBomb && topRightBomb.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (leftBomb && leftBomb.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (rightBomb && rightBomb.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (bottomLeftBomb && bottomLeftBomb.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (bottomBomb && bottomBomb.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (bottomRightBomb && bottomRightBomb.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (numberOfBombs > 0) {\n        cells[rowIndex][colIndex] = {\n          ...currentCell,\n          value: numberOfBombs\n        };\n      }\n    } // inner for loop\n  } // outer for loop\n\n  return cells;\n};","map":{"version":3,"names":["MAX_ROWS","MAX_COLS","NO_OF_BOMBS","CellValue","CellState","generateCells","cells","row","push","col","value","none","state","open","bombsPlaced","randomRow","Math","floor","random","randomCol","currentCell","bomb","map","rowIndex","cell","colIndex","numberOfBombs","topLeftBomb","topBomb","topRightBomb","leftBomb","rightBomb","bottomLeftBomb","bottomBomb","bottomRightBomb"],"sources":["/Users/dr_frankenmiller/Projects/react-minesweeper/src/utils/index.ts"],"sourcesContent":["import React from \"react\";\nimport { MAX_ROWS, MAX_COLS, NO_OF_BOMBS } from \"../constants\";\nimport { CellValue, CellState, Cell } from \"../types\";\n\nexport const generateCells = (): Cell[][] => {\n    let cells: Cell[][] = [];\n  \n    // generating all cells\n    for (let row = 0; row < MAX_ROWS; row++) {\n      cells.push([]);\n      for (let col = 0; col < MAX_COLS; col++) {\n        cells[row].push({\n          value: CellValue.none,\n          state: CellState.open\n        });\n      }\n    }\n\n  // randomly put 10 bombs\n  let bombsPlaced = 0;\n  while (bombsPlaced < NO_OF_BOMBS) {\n    const randomRow = Math.floor(Math.random() * MAX_ROWS);\n    const randomCol = Math.floor(Math.random() * MAX_COLS);\n\n    const currentCell = cells[randomRow][randomCol];\n    if (currentCell.value !== CellValue.bomb) {\n      cells = cells.map((row, rowIndex) =>\n        row.map((cell, colIndex) => {\n          if (randomRow === rowIndex && randomCol === colIndex) {\n            return {\n              ...cell,\n              value: CellValue.bomb\n            };\n          }\n          return cell;\n        })\n      );\n      bombsPlaced++;\n    } // if statement\n  } // while loop\n\n  // calculate the numerals that correspons with cells adjacent to bombs\n  for (let rowIndex=0; rowIndex<MAX_ROWS; rowIndex++) {\n    for (let colIndex=0; colIndex<MAX_COLS; colIndex++) {\n        const currentCell = cells[rowIndex][colIndex];\n        if (currentCell.value === CellValue.bomb) {\n            continue;\n        }\n        let numberOfBombs = 0;\n        const topLeftBomb = rowIndex>0 && colIndex>0 ? cells[rowIndex-1][colIndex-1] : null;\n        const topBomb = rowIndex > 0 ? cells[rowIndex-1][colIndex] : null;\n        const topRightBomb = rowIndex>0 && colIndex<MAX_COLS-1 ? cells[rowIndex-1][colIndex+1] : null;\n        const leftBomb = colIndex > 0 ? cells[rowIndex][colIndex-1] : null;\n        const rightBomb = colIndex < MAX_COLS -1 ? cells[rowIndex][colIndex+1] : null;\n        const bottomLeftBomb = rowIndex<MAX_ROWS-1 && colIndex>0 ? cells[rowIndex+1][colIndex-1] : null;\n        const bottomBomb = rowIndex<MAX_ROWS-1 ? cells[rowIndex+1][colIndex] : null;\n        const bottomRightBomb = rowIndex<MAX_ROWS-1 && colIndex<MAX_COLS-1 ?cells[rowIndex+1][colIndex+1] : null;\n\n        if (topLeftBomb && topLeftBomb.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (topBomb && topBomb.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (topRightBomb && topRightBomb.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (leftBomb && leftBomb.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (rightBomb && rightBomb.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (bottomLeftBomb && bottomLeftBomb.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (bottomBomb && bottomBomb.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (bottomRightBomb && bottomRightBomb.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (numberOfBombs > 0) {\n            cells[rowIndex][colIndex] = {\n                ...currentCell,\n                value: numberOfBombs\n            }\n        }\n\n    } // inner for loop\n  } // outer for loop\n\n    return cells;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}