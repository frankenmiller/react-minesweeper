{"ast":null,"code":"import { MAX_ROWS, MAX_COLS, NO_OF_BOMBS } from \"../constants\";\nimport { CellValue, CellState } from \"../types\";\nconst grabAllAdjacentCells = (cells, rowParam, colParam) => {\n  const topLeftCell = rowParam > 0 && colParam > 0 ? cells[rowParam - 1][colParam - 1] : null;\n  const topCell = rowParam > 0 ? cells[rowParam - 1][colParam] : null;\n  const topRightCell = rowParam > 0 && colParam < MAX_COLS - 1 ? cells[rowParam - 1][colParam + 1] : null;\n  const leftCell = colParam > 0 ? cells[rowParam][colParam - 1] : null;\n  const rightCell = colParam < MAX_COLS - 1 ? cells[rowParam][colParam + 1] : null;\n  const bottomLeftCell = rowParam < MAX_ROWS - 1 && colParam > 0 ? cells[rowParam + 1][colParam - 1] : null;\n  const bottomCell = rowParam < MAX_ROWS - 1 ? cells[rowParam + 1][colParam] : null;\n  const bottomRightCell = rowParam < MAX_ROWS - 1 && colParam < MAX_COLS - 1 ? cells[rowParam + 1][colParam + 1] : null;\n  return {\n    topLeftCell,\n    topCell,\n    topRightCell,\n    leftCell,\n    rightCell,\n    bottomLeftCell,\n    bottomCell,\n    bottomRightCell\n  };\n}; // <!---------------------------------- close ------ grabAllAdjacentCells()\n\nexport const generateCells = () => {\n  let cells = [];\n\n  // generating all cells\n  for (let row = 0; row < MAX_ROWS; row++) {\n    cells.push([]);\n    for (let col = 0; col < MAX_COLS; col++) {\n      cells[row].push({\n        value: CellValue.none,\n        state: CellState.open\n      });\n    }\n  }\n\n  // randomly put 10 bombs\n  let bombsPlaced = 0;\n  while (bombsPlaced < NO_OF_BOMBS) {\n    const randomRow = Math.floor(Math.random() * MAX_ROWS);\n    const randomCol = Math.floor(Math.random() * MAX_COLS);\n    const currentCell = cells[randomRow][randomCol];\n    if (currentCell.value !== CellValue.bomb) {\n      cells = cells.map((row, rowIndex) => row.map((cell, colIndex) => {\n        if (randomRow === rowIndex && randomCol === colIndex) {\n          return {\n            ...cell,\n            value: CellValue.bomb\n          };\n        }\n        return cell;\n      }));\n      bombsPlaced++;\n    } // if statement\n  } // while loop\n\n  // calculate the numerals that correspond w/cells adjacent to bombs\n  for (let rowIndex = 0; rowIndex < MAX_ROWS; rowIndex++) {\n    for (let colIndex = 0; colIndex < MAX_COLS; colIndex++) {\n      const currentCell = cells[rowIndex][colIndex];\n      if (currentCell.value === CellValue.bomb) {\n        continue;\n      }\n      let numberOfBombs = 0;\n      const {\n        topLeftCell,\n        topCell,\n        topRightCell,\n        leftCell,\n        rightCell,\n        bottomLeftCell,\n        bottomCell,\n        bottomRightCell\n      } = grabAllAdjacentCells(cells, rowIndex, colIndex);\n\n      // const topLeftCell = rowIndex>0 && colIndex>0 ? cells[rowIndex-1][colIndex-1] : null;\n      // const topCell = rowIndex > 0 ? cells[rowIndex-1][colIndex] : null;\n      // const topRightCell = rowIndex>0 && colIndex<MAX_COLS-1 ? cells[rowIndex-1][colIndex+1] : null;\n      // const leftCell = colIndex > 0 ? cells[rowIndex][colIndex-1] : null;\n      // const rightCell = colIndex < MAX_COLS -1 ? cells[rowIndex][colIndex+1] : null;\n      // const bottomLeftCell = rowIndex<MAX_ROWS-1 && colIndex>0 ? cells[rowIndex+1][colIndex-1] : null;\n      // const bottomCell = rowIndex<MAX_ROWS-1 ? cells[rowIndex+1][colIndex] : null;\n      // const bottomRightCell = rowIndex<MAX_ROWS-1 && colIndex<MAX_COLS-1 ?cells[rowIndex+1][colIndex+1] : null;\n\n      if (topLeftCell && topLeftCell.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (topCell && topCell.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (topRightCell && topRightCell.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (leftCell && leftCell.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (rightCell && rightCell.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (bottomLeftCell && bottomLeftCell.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (bottomCell && bottomCell.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (bottomRightCell && bottomRightCell.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (numberOfBombs > 0) {\n        cells[rowIndex][colIndex] = {\n          ...currentCell,\n          value: numberOfBombs\n        };\n      }\n    } // inner for-loop\n  } // outer for-loop\n\n  return cells;\n}; // <!-------------------------------------- close ------- generateCells()\n\nexport const openMultipleCells = (cells, rowParam, colParam) => {\n  let newCells = cells.slice();\n  // const currentCell = cells[rowParam][colParam]; delete later if un-needed\n  newCells[rowParam][colParam].state = CellState.open;\n  const {\n    topLeftCell,\n    topCell,\n    topRightCell,\n    leftCell,\n    rightCell,\n    bottomLeftCell,\n    bottomCell,\n    bottomRightCell\n  } = grabAllAdjacentCells(cells, rowParam, colParam);\n  if (topLeftCell && topLeftCell.state !== CellState.open && topLeftCell.value !== CellValue.bomb) {\n    if (topLeftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam - 1);\n    } else {\n      newCells[rowParam - 1][colParam - 1].state = CellState.visible;\n    }\n  } // outer if-statement for topLeftCell\n  if (topCell && topCell.state !== CellState.open && topCell.value !== CellValue.bomb) {\n    if (topCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam);\n    } else {\n      newCells[rowParam - 1][colParam].state = CellState.visible;\n    }\n  } // outer if-statement for topCell\n  if (topRightCell && topRightCell.state !== CellState.open && topRightCell.value !== CellValue.bomb) {\n    if (topRightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam + 1);\n    } else {\n      newCells[rowParam - 1][colParam + 1].state = CellState.visible;\n    }\n  } // outer if-statement for topRightCell\n  if (leftCell && leftCell.state !== CellState.open && leftCell.value !== CellValue.bomb) {\n    if (leftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam, colParam - 1);\n    } else {\n      newCells[rowParam][colParam - 1].state = CellState.visible;\n    }\n  } // outer if-statement for leftCell\n  if (rightCell && rightCell.state !== CellState.open && rightCell.value !== CellValue.bomb) {\n    if (rightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam, colParam + 1);\n    } else {\n      newCells[rowParam][colParam + 1].state = CellState.visible;\n    }\n  } // outer if-statement for rightCell\n  if (bottomLeftCell && bottomLeftCell.state !== CellState.open && bottomLeftCell.value !== CellValue.bomb) {\n    if (bottomLeftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam - 1);\n    } else {\n      newCells[rowParam + 1][colParam - 1].state = CellState.visible;\n    }\n  } // outer if-statement for bottomLeftCell\n  if (bottomCell && bottomCell.state !== CellState.open && bottomCell.value !== CellValue.bomb) {\n    if (bottomCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam);\n    } else {\n      newCells[rowParam + 1][colParam].state = CellState.visible;\n    }\n  } // outer if-statement for bottomCell\n  if (bottomRightCell && bottomRightCell.state !== CellState.open && bottomRightCell.value !== CellValue.bomb) {\n    if (bottomRightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam + 1);\n    } else {\n      newCells[rowParam + 1][colParam + 1].state = CellState.visible;\n    }\n  } // outer if-statement for bottomRightCell\n  return newCells;\n}; // <!---------------------------------- close ------- openMultipleCells()","map":{"version":3,"names":["MAX_ROWS","MAX_COLS","NO_OF_BOMBS","CellValue","CellState","grabAllAdjacentCells","cells","rowParam","colParam","topLeftCell","topCell","topRightCell","leftCell","rightCell","bottomLeftCell","bottomCell","bottomRightCell","generateCells","row","push","col","value","none","state","open","bombsPlaced","randomRow","Math","floor","random","randomCol","currentCell","bomb","map","rowIndex","cell","colIndex","numberOfBombs","openMultipleCells","newCells","slice","visible"],"sources":["/Users/dr_frankenmiller/Projects/react-minesweeper/src/utils/index.ts"],"sourcesContent":["import React from \"react\";\nimport { MAX_ROWS, MAX_COLS, NO_OF_BOMBS } from \"../constants\";\nimport { CellValue, CellState, Cell } from \"../types\";\n\nconst grabAllAdjacentCells = ( // <!------------------ grabAllAdjacentCells()\n  cells: Cell[][], rowParam: number, colParam: number\n): { // types of the outputs\n  topLeftCell: Cell | null;\n  topCell: Cell | null;\n  topRightCell: Cell | null;\n  leftCell: Cell | null;\n  rightCell: Cell | null;\n  bottomLeftCell: Cell | null;\n  bottomCell: Cell | null;\n  bottomRightCell: Cell | null;\n} => {\n  const topLeftCell = rowParam>0 && colParam>0 ? cells[rowParam-1][colParam-1] : null;\n  const topCell = rowParam > 0 ? cells[rowParam-1][colParam] : null;\n  const topRightCell = rowParam>0 && colParam<MAX_COLS-1 ? cells[rowParam-1][colParam+1] : null;\n  const leftCell = colParam > 0 ? cells[rowParam][colParam-1] : null;\n  const rightCell = colParam < MAX_COLS -1 ? cells[rowParam][colParam+1] : null;\n  const bottomLeftCell = rowParam<MAX_ROWS-1 && colParam>0 ? cells[rowParam+1][colParam-1] : null;\n  const bottomCell = rowParam<MAX_ROWS-1 ? cells[rowParam+1][colParam] : null;\n  const bottomRightCell = rowParam<MAX_ROWS-1 && colParam<MAX_COLS-1 ?cells[rowParam+1][colParam+1] : null;\n\n  return {\n    topLeftCell,\n    topCell,\n    topRightCell,\n    leftCell,\n    rightCell,\n    bottomLeftCell,\n    bottomCell,\n    bottomRightCell\n  }\n};  // <!---------------------------------- close ------ grabAllAdjacentCells()\n\nexport const generateCells = (): Cell[][] => {\n    let cells: Cell[][] = [];\n  \n    // generating all cells\n    for (let row = 0; row < MAX_ROWS; row++) {\n      cells.push([]);\n      for (let col = 0; col < MAX_COLS; col++) {\n        cells[row].push({\n          value: CellValue.none,\n          state: CellState.open\n        });\n      }\n    }\n\n  // randomly put 10 bombs\n  let bombsPlaced = 0;\n  while (bombsPlaced < NO_OF_BOMBS) {\n    const randomRow = Math.floor(Math.random() * MAX_ROWS);\n    const randomCol = Math.floor(Math.random() * MAX_COLS);\n\n    const currentCell = cells[randomRow][randomCol];\n    if (currentCell.value !== CellValue.bomb) {\n      cells = cells.map((row, rowIndex) =>\n        row.map((cell, colIndex) => {\n          if (randomRow === rowIndex && randomCol === colIndex) {\n            return {\n              ...cell,\n              value: CellValue.bomb\n            };\n          }\n          return cell;\n        })\n      );\n      bombsPlaced++;\n    } // if statement\n  } // while loop\n\n  // calculate the numerals that correspond w/cells adjacent to bombs\n  for (let rowIndex=0; rowIndex<MAX_ROWS; rowIndex++) {\n    for (let colIndex=0; colIndex<MAX_COLS; colIndex++) {\n        const currentCell = cells[rowIndex][colIndex];\n        if (currentCell.value === CellValue.bomb) {\n            continue;\n        }\n        let numberOfBombs = 0;\n\n        const { topLeftCell, topCell, topRightCell, leftCell, rightCell, bottomLeftCell, \n          bottomCell, bottomRightCell} = grabAllAdjacentCells(cells, rowIndex, colIndex);\n\n        // const topLeftCell = rowIndex>0 && colIndex>0 ? cells[rowIndex-1][colIndex-1] : null;\n        // const topCell = rowIndex > 0 ? cells[rowIndex-1][colIndex] : null;\n        // const topRightCell = rowIndex>0 && colIndex<MAX_COLS-1 ? cells[rowIndex-1][colIndex+1] : null;\n        // const leftCell = colIndex > 0 ? cells[rowIndex][colIndex-1] : null;\n        // const rightCell = colIndex < MAX_COLS -1 ? cells[rowIndex][colIndex+1] : null;\n        // const bottomLeftCell = rowIndex<MAX_ROWS-1 && colIndex>0 ? cells[rowIndex+1][colIndex-1] : null;\n        // const bottomCell = rowIndex<MAX_ROWS-1 ? cells[rowIndex+1][colIndex] : null;\n        // const bottomRightCell = rowIndex<MAX_ROWS-1 && colIndex<MAX_COLS-1 ?cells[rowIndex+1][colIndex+1] : null;\n\n        if (topLeftCell && topLeftCell.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (topCell && topCell.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (topRightCell && topRightCell.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (leftCell && leftCell.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (rightCell && rightCell.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (bottomLeftCell && bottomLeftCell.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (bottomCell && bottomCell.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (bottomRightCell && bottomRightCell.value === CellValue.bomb) {\n            numberOfBombs++;\n        }\n        if (numberOfBombs > 0) {\n            cells[rowIndex][colIndex] = {\n                ...currentCell,\n                value: numberOfBombs\n            }\n        }\n\n    } // inner for-loop\n  } // outer for-loop\n\n    return cells;\n}; // <!-------------------------------------- close ------- generateCells()\n\nexport const openMultipleCells = ( // <!----------------- openMultipleCells()\n  cells: Cell[][], rowParam: number, colParam: number\n): Cell[][] => {\n  let newCells = cells.slice();\n  // const currentCell = cells[rowParam][colParam]; delete later if un-needed\n  newCells[rowParam][colParam].state = CellState.open;\n  const {topLeftCell, topCell, topRightCell, leftCell, rightCell, bottomLeftCell,\n    bottomCell, bottomRightCell} = grabAllAdjacentCells(cells, rowParam, colParam);  \n  \n  if (topLeftCell && topLeftCell.state !== CellState.open &&\n     topLeftCell.value !== CellValue.bomb) {\n      if (topLeftCell.value === CellValue.none) {\n        newCells = openMultipleCells(newCells, rowParam-1, colParam-1);\n      } else {\n        newCells[rowParam-1][colParam-1].state = CellState.visible;\n      }\n  } // outer if-statement for topLeftCell\n  if (topCell && topCell.state !== CellState.open &&\n    topCell.value !== CellValue.bomb) {\n      if (topCell.value === CellValue.none) {\n        newCells = openMultipleCells(newCells, rowParam-1, colParam);\n      } else {\n        newCells[rowParam-1][colParam].state = CellState.visible;\n      }\n  } // outer if-statement for topCell\n  if (topRightCell && topRightCell.state !== CellState.open &&\n    topRightCell.value !== CellValue.bomb) {\n      if (topRightCell.value === CellValue.none) {\n        newCells = openMultipleCells(newCells, rowParam-1, colParam+1);\n      } else {\n        newCells[rowParam-1][colParam+1].state = CellState.visible;\n      }\n  } // outer if-statement for topRightCell\n  if (leftCell && leftCell.state !== CellState.open &&\n    leftCell.value !== CellValue.bomb) {\n      if (leftCell.value === CellValue.none) {\n        newCells = openMultipleCells(newCells, rowParam, colParam-1);\n      } else {\n        newCells[rowParam][colParam-1].state = CellState.visible;\n      }\n  } // outer if-statement for leftCell\n  if (rightCell && rightCell.state !== CellState.open &&\n    rightCell.value !== CellValue.bomb) {\n      if (rightCell.value === CellValue.none) {\n        newCells = openMultipleCells(newCells, rowParam, colParam+1);\n      } else {\n        newCells[rowParam][colParam+1].state = CellState.visible;\n      }\n  } // outer if-statement for rightCell\n  if (bottomLeftCell && bottomLeftCell.state !== CellState.open &&\n      bottomLeftCell.value !== CellValue.bomb) {\n      if (bottomLeftCell.value === CellValue.none) {\n        newCells = openMultipleCells(newCells, rowParam+1, colParam-1);\n      } else {\n        newCells[rowParam+1][colParam-1].state = CellState.visible;\n      }\n  } // outer if-statement for bottomLeftCell\n  if (bottomCell && bottomCell.state !== CellState.open &&\n    bottomCell.value !== CellValue.bomb) {\n      if (bottomCell.value === CellValue.none) {\n        newCells = openMultipleCells(newCells, rowParam+1, colParam);\n      } else {\n        newCells[rowParam+1][colParam].state = CellState.visible;\n      }\n  } // outer if-statement for bottomCell\n  if (bottomRightCell && bottomRightCell.state !== CellState.open &&\n    bottomRightCell.value !== CellValue.bomb) {\n      if (bottomRightCell.value === CellValue.none) {\n        newCells = openMultipleCells(newCells, rowParam+1, colParam+1);\n      } else {\n        newCells[rowParam+1][colParam+1].state = CellState.visible;\n      }\n  } // outer if-statement for bottomRightCell\n  return newCells;\n\n}; // <!---------------------------------- close ------- openMultipleCells()"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}