{"ast":null,"code":"import { MAX_COLS, MAX_ROWS, NO_OF_BOMBS } from \"../constants\";\nimport { CellState, CellValue } from \"../types\";\nconst grabAllAdjacentCells = (cells, rowParam, colParam) => {\n  const topLeftCell = rowParam > 0 && colParam > 0 ? cells[rowParam - 1][colParam - 1] : null;\n  const topCell = rowParam > 0 ? cells[rowParam - 1][colParam] : null;\n  const topRightCell = rowParam > 0 && colParam < MAX_COLS - 1 ? cells[rowParam - 1][colParam + 1] : null;\n  const leftCell = colParam > 0 ? cells[rowParam][colParam - 1] : null;\n  const rightCell = colParam < MAX_COLS - 1 ? cells[rowParam][colParam + 1] : null;\n  const bottomLeftCell = rowParam < MAX_ROWS - 1 && colParam > 0 ? cells[rowParam + 1][colParam - 1] : null;\n  const bottomCell = rowParam < MAX_ROWS - 1 ? cells[rowParam + 1][colParam] : null;\n  const bottomRightCell = rowParam < MAX_ROWS - 1 && colParam < MAX_COLS - 1 ? cells[rowParam + 1][colParam + 1] : null;\n  return {\n    topLeftCell,\n    topCell,\n    topRightCell,\n    leftCell,\n    rightCell,\n    bottomLeftCell,\n    bottomCell,\n    bottomRightCell\n  };\n};\nexport const generateCells = () => {\n  let cells = [];\n\n  // generating all cells\n  for (let row = 0; row < MAX_ROWS; row++) {\n    cells.push([]);\n    for (let col = 0; col < MAX_COLS; col++) {\n      cells[row].push({\n        value: CellValue.none,\n        state: CellState.open\n      });\n    }\n  }\n\n  // randomly put 10 bombs\n  let bombsPlaced = 0;\n  while (bombsPlaced < NO_OF_BOMBS) {\n    const randomRow = Math.floor(Math.random() * MAX_ROWS);\n    const randomCol = Math.floor(Math.random() * MAX_COLS);\n    const currentCell = cells[randomRow][randomCol];\n    if (currentCell.value !== CellValue.bomb) {\n      cells = cells.map((row, rowIndex) => row.map((cell, colIndex) => {\n        if (randomRow === rowIndex && randomCol === colIndex) {\n          return {\n            ...cell,\n            value: CellValue.bomb\n          };\n        }\n        return cell;\n      }));\n      bombsPlaced++;\n    }\n  }\n\n  // calculate the numbers for each cell\n  for (let rowIndex = 0; rowIndex < MAX_ROWS; rowIndex++) {\n    for (let colIndex = 0; colIndex < MAX_COLS; colIndex++) {\n      const currentCell = cells[rowIndex][colIndex];\n      if (currentCell.value === CellValue.bomb) {\n        continue;\n      }\n      let numberOfBombs = 0;\n      const {\n        topLeftCell,\n        topCell,\n        topRightCell,\n        leftCell,\n        rightCell,\n        bottomLeftCell,\n        bottomCell,\n        bottomRightCell\n      } = grabAllAdjacentCells(cells, rowIndex, colIndex);\n      if ((topLeftCell === null || topLeftCell === void 0 ? void 0 : topLeftCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((topCell === null || topCell === void 0 ? void 0 : topCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((topRightCell === null || topRightCell === void 0 ? void 0 : topRightCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((leftCell === null || leftCell === void 0 ? void 0 : leftCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((rightCell === null || rightCell === void 0 ? void 0 : rightCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((bottomLeftCell === null || bottomLeftCell === void 0 ? void 0 : bottomLeftCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((bottomCell === null || bottomCell === void 0 ? void 0 : bottomCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((bottomRightCell === null || bottomRightCell === void 0 ? void 0 : bottomRightCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (numberOfBombs > 0) {\n        cells[rowIndex][colIndex] = {\n          ...currentCell,\n          value: numberOfBombs\n        };\n      }\n    }\n  }\n  return cells;\n};\nexport const openMultipleCells = (cells, rowParam, colParam) => {\n  const currentCell = cells[rowParam][colParam];\n  if (currentCell.state === CellState.visible || currentCell.state === CellState.flagged) {\n    return cells;\n  }\n  let newCells = cells.slice();\n  newCells[rowParam][colParam].state = CellState.visible;\n  const {\n    topLeftCell,\n    topCell,\n    topRightCell,\n    leftCell,\n    rightCell,\n    bottomLeftCell,\n    bottomCell,\n    bottomRightCell\n  } = grabAllAdjacentCells(cells, rowParam, colParam);\n  if ((topLeftCell === null || topLeftCell === void 0 ? void 0 : topLeftCell.state) === CellState.open && topLeftCell.value !== CellValue.bomb) {\n    if (topLeftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam - 1);\n    } else {\n      newCells[rowParam - 1][colParam - 1].state = CellState.visible;\n    }\n  }\n  if ((topCell === null || topCell === void 0 ? void 0 : topCell.state) === CellState.open && topCell.value !== CellValue.bomb) {\n    if (topCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam);\n    } else {\n      newCells[rowParam - 1][colParam].state = CellState.visible;\n    }\n  }\n  if ((topRightCell === null || topRightCell === void 0 ? void 0 : topRightCell.state) === CellState.open && topRightCell.value !== CellValue.bomb) {\n    if (topRightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam + 1);\n    } else {\n      newCells[rowParam - 1][colParam + 1].state = CellState.visible;\n    }\n  }\n  if ((leftCell === null || leftCell === void 0 ? void 0 : leftCell.state) === CellState.open && leftCell.value !== CellValue.bomb) {\n    if (leftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam, colParam - 1);\n    } else {\n      newCells[rowParam][colParam - 1].state = CellState.visible;\n    }\n  }\n  if ((rightCell === null || rightCell === void 0 ? void 0 : rightCell.state) === CellState.open && rightCell.value !== CellValue.bomb) {\n    if (rightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam, colParam + 1);\n    } else {\n      newCells[rowParam][colParam + 1].state = CellState.visible;\n    }\n  }\n  if ((bottomLeftCell === null || bottomLeftCell === void 0 ? void 0 : bottomLeftCell.state) === CellState.open && bottomLeftCell.value !== CellValue.bomb) {\n    if (bottomLeftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam - 1);\n    } else {\n      newCells[rowParam + 1][colParam - 1].state = CellState.visible;\n    }\n  }\n  if ((bottomCell === null || bottomCell === void 0 ? void 0 : bottomCell.state) === CellState.open && bottomCell.value !== CellValue.bomb) {\n    if (bottomCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam);\n    } else {\n      newCells[rowParam + 1][colParam].state = CellState.visible;\n    }\n  }\n  if ((bottomRightCell === null || bottomRightCell === void 0 ? void 0 : bottomRightCell.state) === CellState.open && bottomRightCell.value !== CellValue.bomb) {\n    if (bottomRightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam + 1);\n    } else {\n      newCells[rowParam + 1][colParam + 1].state = CellState.visible;\n    }\n  }\n  return newCells;\n};\n\n// import React from \"react\";\n// import { MAX_ROWS, MAX_COLS, NO_OF_BOMBS } from \"../constants\";\n// import { CellValue, CellState, Cell } from \"../types\";\n\n// const grabAllAdjacentCells = ( // <!------------------ grabAllAdjacentCells()\n//   cells: Cell[][], rowParam: number, colParam: number\n// ): { // types of the outputs\n//   topLeftCell: Cell | null;\n//   topCell: Cell | null;\n//   topRightCell: Cell | null;\n//   leftCell: Cell | null;\n//   rightCell: Cell | null;\n//   bottomLeftCell: Cell | null;\n//   bottomCell: Cell | null;\n//   bottomRightCell: Cell | null;\n// } => {\n//   const topLeftCell = rowParam>0 && colParam>0 ? cells[rowParam-1][colParam-1] : null;\n//   const topCell = rowParam > 0 ? cells[rowParam-1][colParam] : null;\n//   const topRightCell = rowParam>0 && colParam<MAX_COLS-1 ? cells[rowParam-1][colParam+1] : null;\n//   const leftCell = colParam > 0 ? cells[rowParam][colParam-1] : null;\n//   const rightCell = colParam < MAX_COLS -1 ? cells[rowParam][colParam+1] : null;\n//   const bottomLeftCell = rowParam<MAX_ROWS-1 && colParam>0 ? cells[rowParam+1][colParam-1] : null;\n//   const bottomCell = rowParam<MAX_ROWS-1 ? cells[rowParam+1][colParam] : null;\n//   const bottomRightCell = rowParam<MAX_ROWS-1 && colParam<MAX_COLS-1 ?cells[rowParam+1][colParam+1] : null;\n\n//   return {\n//     topLeftCell,\n//     topCell,\n//     topRightCell,\n//     leftCell,\n//     rightCell,\n//     bottomLeftCell,\n//     bottomCell,\n//     bottomRightCell\n//   }\n// };  // <!---------------------------------- close ------ grabAllAdjacentCells()\n\n// export const generateCells = (): Cell[][] => {\n//     let cells: Cell[][] = [];\n\n//     // generating all cells\n//     for (let row = 0; row < MAX_ROWS; row++) {\n//       cells.push([]);\n//       for (let col = 0; col < MAX_COLS; col++) {\n//         cells[row].push({\n//           value: CellValue.none,\n//           state: CellState.open\n//         });\n//       }\n//     }\n\n//   // randomly put 10 bombs\n//   let bombsPlaced = 0;\n//   while (bombsPlaced < NO_OF_BOMBS) {\n//     const randomRow = Math.floor(Math.random() * MAX_ROWS);\n//     const randomCol = Math.floor(Math.random() * MAX_COLS);\n\n//     const currentCell = cells[randomRow][randomCol];\n//     if (currentCell.value !== CellValue.bomb) {\n//       cells = cells.map((row, rowIndex) =>\n//         row.map((cell, colIndex) => {\n//           if (randomRow === rowIndex && randomCol === colIndex) {\n//             return {\n//               ...cell,\n//               value: CellValue.bomb\n//             };\n//           }\n//           return cell;\n//         })\n//       );\n//       bombsPlaced++;\n//     } // if statement\n//   } // while loop\n\n//   // calculate the numerals that correspond w/cells adjacent to bombs\n//   for (let rowIndex=0; rowIndex<MAX_ROWS; rowIndex++) {\n//     for (let colIndex=0; colIndex<MAX_COLS; colIndex++) {\n//         const currentCell = cells[rowIndex][colIndex];\n//         if (currentCell.value === CellValue.bomb) {\n//             continue;\n//         }\n//         let numberOfBombs = 0;\n\n//         const {\n//           topLeftCell,\n//           topCell,\n//           topRightCell,\n//           leftCell,\n//           rightCell,\n//           bottomLeftCell,\n//           bottomCell,\n//           bottomRightCell\n//         } = grabAllAdjacentCells(cells, rowIndex, colIndex);\n\n//         // const topLeftCell = rowIndex>0 && colIndex>0 ? cells[rowIndex-1][colIndex-1] : null;\n//         // const topCell = rowIndex > 0 ? cells[rowIndex-1][colIndex] : null;\n//         // const topRightCell = rowIndex>0 && colIndex<MAX_COLS-1 ? cells[rowIndex-1][colIndex+1] : null;\n//         // const leftCell = colIndex > 0 ? cells[rowIndex][colIndex-1] : null;\n//         // const rightCell = colIndex < MAX_COLS -1 ? cells[rowIndex][colIndex+1] : null;\n//         // const bottomLeftCell = rowIndex<MAX_ROWS-1 && colIndex>0 ? cells[rowIndex+1][colIndex-1] : null;\n//         // const bottomCell = rowIndex<MAX_ROWS-1 ? cells[rowIndex+1][colIndex] : null;\n//         // const bottomRightCell = rowIndex<MAX_ROWS-1 && colIndex<MAX_COLS-1 ?cells[rowIndex+1][colIndex+1] : null;\n\n//         if (topLeftCell && topLeftCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (topCell && topCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (topRightCell && topRightCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (leftCell && leftCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (rightCell && rightCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (bottomLeftCell && bottomLeftCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (bottomCell && bottomCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (bottomRightCell && bottomRightCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (numberOfBombs > 0) {\n//             cells[rowIndex][colIndex] = {\n//                 ...currentCell,\n//                 value: numberOfBombs\n//             }\n//         }\n\n//     } // inner for-loop\n//   } // outer for-loop\n\n//     return cells;\n// }; // <!-------------------------------------- close ------- generateCells()\n\n// export const openMultipleCells = ( // <!----------------- openMultipleCells()\n//   cells: Cell[][], \n//   rowParam: number, \n//   colParam: number\n// ): Cell[][] => {\n//   const currentCell = cells[rowParam][colParam];\n\n//   if (\n//     currentCell.state === CellState.visible || \n//     currentCell.state === CellState.flagged\n//   ) {\n//       return cells;\n//   }\n\n//   let newCells = cells.slice();\n\n//   newCells[rowParam][colParam].state = CellState.visible;\n//   const {\n//     topLeftCell,\n//     topCell,\n//     topRightCell,\n//     leftCell,\n//     rightCell,\n//     bottomLeftCell,\n//     bottomCell,\n//     bottomRightCell\n//   } = grabAllAdjacentCells(cells, rowParam, colParam);\n\n//   if (topLeftCell && topLeftCell.state !== CellState.open &&\n//      topLeftCell.value !== CellValue.bomb) {\n//       if (topLeftCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam-1, colParam-1);\n//       } else {\n//         newCells[rowParam-1][colParam-1].state = CellState.visible;\n//       }\n//   } // outer if-statement for topLeftCell\n//   if (topCell && topCell.state !== CellState.open &&\n//     topCell.value !== CellValue.bomb) {\n//       if (topCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam-1, colParam);\n//       } else {\n//         newCells[rowParam-1][colParam].state = CellState.visible;\n//       }\n//   } // outer if-statement for topCell\n//   if (topRightCell && topRightCell.state !== CellState.open &&\n//     topRightCell.value !== CellValue.bomb) {\n//       if (topRightCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam-1, colParam+1);\n//       } else {\n//         newCells[rowParam-1][colParam+1].state = CellState.visible;\n//       }\n//   } // outer if-statement for topRightCell\n//   if (leftCell && leftCell.state !== CellState.open &&\n//     leftCell.value !== CellValue.bomb) {\n//       if (leftCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam, colParam-1);\n//       } else {\n//         newCells[rowParam][colParam-1].state = CellState.visible;\n//       }\n//   } // outer if-statement for leftCell\n//   if (rightCell && rightCell.state !== CellState.open &&\n//     rightCell.value !== CellValue.bomb) {\n//       if (rightCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam, colParam+1);\n//       } else {\n//         newCells[rowParam][colParam+1].state = CellState.visible;\n//       }\n//   } // outer if-statement for rightCell\n//   if (bottomLeftCell && bottomLeftCell.state !== CellState.open &&\n//       bottomLeftCell.value !== CellValue.bomb) {\n//       if (bottomLeftCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam+1, colParam-1);\n//       } else {\n//         newCells[rowParam+1][colParam-1].state = CellState.visible;\n//       }\n//   } // outer if-statement for bottomLeftCell\n//   if (bottomCell && bottomCell.state !== CellState.open &&\n//     bottomCell.value !== CellValue.bomb) {\n//       if (bottomCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam+1, colParam);\n//       } else {\n//         newCells[rowParam+1][colParam].state = CellState.visible;\n//       }\n//   } // outer if-statement for bottomCell\n//   if (bottomRightCell && bottomRightCell.state !== CellState.open &&\n//     bottomRightCell.value !== CellValue.bomb) {\n//       if (bottomRightCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam+1, colParam+1);\n//       } else {\n//         newCells[rowParam+1][colParam+1].state = CellState.visible;\n//       }\n//   } // outer if-statement for bottomRightCell\n//   return newCells;\n\n// }; // <!---------------------------------- close ------- openMultipleCells()","map":{"version":3,"names":["MAX_COLS","MAX_ROWS","NO_OF_BOMBS","CellState","CellValue","grabAllAdjacentCells","cells","rowParam","colParam","topLeftCell","topCell","topRightCell","leftCell","rightCell","bottomLeftCell","bottomCell","bottomRightCell","generateCells","row","push","col","value","none","state","open","bombsPlaced","randomRow","Math","floor","random","randomCol","currentCell","bomb","map","rowIndex","cell","colIndex","numberOfBombs","openMultipleCells","visible","flagged","newCells","slice"],"sources":["/Users/dr_frankenmiller/Projects/react-minesweeper/src/utils/index.ts"],"sourcesContent":["import { MAX_COLS, MAX_ROWS, NO_OF_BOMBS } from \"../constants\";\nimport { Cell, CellState, CellValue } from \"../types\";\n\nconst grabAllAdjacentCells = (\n  cells: Cell[][],\n  rowParam: number,\n  colParam: number\n): {\n  topLeftCell: Cell | null;\n  topCell: Cell | null;\n  topRightCell: Cell | null;\n  leftCell: Cell | null;\n  rightCell: Cell | null;\n  bottomLeftCell: Cell | null;\n  bottomCell: Cell | null;\n  bottomRightCell: Cell | null;\n} => {\n  const topLeftCell =\n    rowParam > 0 && colParam > 0 ? cells[rowParam - 1][colParam - 1] : null;\n  const topCell = rowParam > 0 ? cells[rowParam - 1][colParam] : null;\n  const topRightCell =\n    rowParam > 0 && colParam < MAX_COLS - 1\n      ? cells[rowParam - 1][colParam + 1]\n      : null;\n  const leftCell = colParam > 0 ? cells[rowParam][colParam - 1] : null;\n  const rightCell =\n    colParam < MAX_COLS - 1 ? cells[rowParam][colParam + 1] : null;\n  const bottomLeftCell =\n    rowParam < MAX_ROWS - 1 && colParam > 0\n      ? cells[rowParam + 1][colParam - 1]\n      : null;\n  const bottomCell =\n    rowParam < MAX_ROWS - 1 ? cells[rowParam + 1][colParam] : null;\n  const bottomRightCell =\n    rowParam < MAX_ROWS - 1 && colParam < MAX_COLS - 1\n      ? cells[rowParam + 1][colParam + 1]\n      : null;\n\n  return {\n    topLeftCell,\n    topCell,\n    topRightCell,\n    leftCell,\n    rightCell,\n    bottomLeftCell,\n    bottomCell,\n    bottomRightCell\n  };\n};\n\nexport const generateCells = (): Cell[][] => {\n  let cells: Cell[][] = [];\n\n  // generating all cells\n  for (let row = 0; row < MAX_ROWS; row++) {\n    cells.push([]);\n    for (let col = 0; col < MAX_COLS; col++) {\n      cells[row].push({\n        value: CellValue.none,\n        state: CellState.open\n      });\n    }\n  }\n\n  // randomly put 10 bombs\n  let bombsPlaced = 0;\n  while (bombsPlaced < NO_OF_BOMBS) {\n    const randomRow = Math.floor(Math.random() * MAX_ROWS);\n    const randomCol = Math.floor(Math.random() * MAX_COLS);\n\n    const currentCell = cells[randomRow][randomCol];\n    if (currentCell.value !== CellValue.bomb) {\n      cells = cells.map((row, rowIndex) =>\n        row.map((cell, colIndex) => {\n          if (randomRow === rowIndex && randomCol === colIndex) {\n            return {\n              ...cell,\n              value: CellValue.bomb\n            };\n          }\n\n          return cell;\n        })\n      );\n      bombsPlaced++;\n    }\n  }\n\n  // calculate the numbers for each cell\n  for (let rowIndex = 0; rowIndex < MAX_ROWS; rowIndex++) {\n    for (let colIndex = 0; colIndex < MAX_COLS; colIndex++) {\n      const currentCell = cells[rowIndex][colIndex];\n      if (currentCell.value === CellValue.bomb) {\n        continue;\n      }\n\n      let numberOfBombs = 0;\n      const {\n        topLeftCell,\n        topCell,\n        topRightCell,\n        leftCell,\n        rightCell,\n        bottomLeftCell,\n        bottomCell,\n        bottomRightCell\n      } = grabAllAdjacentCells(cells, rowIndex, colIndex);\n\n      if (topLeftCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (topCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (topRightCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (leftCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (rightCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (bottomLeftCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (bottomCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (bottomRightCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n\n      if (numberOfBombs > 0) {\n        cells[rowIndex][colIndex] = {\n          ...currentCell,\n          value: numberOfBombs\n        };\n      }\n    }\n  }\n\n  return cells;\n};\n\nexport const openMultipleCells = (\n  cells: Cell[][],\n  rowParam: number,\n  colParam: number\n): Cell[][] => {\n  const currentCell = cells[rowParam][colParam];\n\n  if (\n    currentCell.state === CellState.visible ||\n    currentCell.state === CellState.flagged\n  ) {\n    return cells;\n  }\n\n  let newCells = cells.slice();\n  newCells[rowParam][colParam].state = CellState.visible;\n\n  const {\n    topLeftCell,\n    topCell,\n    topRightCell,\n    leftCell,\n    rightCell,\n    bottomLeftCell,\n    bottomCell,\n    bottomRightCell\n  } = grabAllAdjacentCells(cells, rowParam, colParam);\n\n  if (\n    topLeftCell?.state === CellState.open &&\n    topLeftCell.value !== CellValue.bomb\n  ) {\n    if (topLeftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam - 1);\n    } else {\n      newCells[rowParam - 1][colParam - 1].state = CellState.visible;\n    }\n  }\n\n  if (topCell?.state === CellState.open && topCell.value !== CellValue.bomb) {\n    if (topCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam);\n    } else {\n      newCells[rowParam - 1][colParam].state = CellState.visible;\n    }\n  }\n\n  if (\n    topRightCell?.state === CellState.open &&\n    topRightCell.value !== CellValue.bomb\n  ) {\n    if (topRightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam + 1);\n    } else {\n      newCells[rowParam - 1][colParam + 1].state = CellState.visible;\n    }\n  }\n\n  if (leftCell?.state === CellState.open && leftCell.value !== CellValue.bomb) {\n    if (leftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam, colParam - 1);\n    } else {\n      newCells[rowParam][colParam - 1].state = CellState.visible;\n    }\n  }\n\n  if (\n    rightCell?.state === CellState.open &&\n    rightCell.value !== CellValue.bomb\n  ) {\n    if (rightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam, colParam + 1);\n    } else {\n      newCells[rowParam][colParam + 1].state = CellState.visible;\n    }\n  }\n\n  if (\n    bottomLeftCell?.state === CellState.open &&\n    bottomLeftCell.value !== CellValue.bomb\n  ) {\n    if (bottomLeftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam - 1);\n    } else {\n      newCells[rowParam + 1][colParam - 1].state = CellState.visible;\n    }\n  }\n\n  if (\n    bottomCell?.state === CellState.open &&\n    bottomCell.value !== CellValue.bomb\n  ) {\n    if (bottomCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam);\n    } else {\n      newCells[rowParam + 1][colParam].state = CellState.visible;\n    }\n  }\n\n  if (\n    bottomRightCell?.state === CellState.open &&\n    bottomRightCell.value !== CellValue.bomb\n  ) {\n    if (bottomRightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam + 1);\n    } else {\n      newCells[rowParam + 1][colParam + 1].state = CellState.visible;\n    }\n  }\n\n  return newCells;\n};\n\n// import React from \"react\";\n// import { MAX_ROWS, MAX_COLS, NO_OF_BOMBS } from \"../constants\";\n// import { CellValue, CellState, Cell } from \"../types\";\n\n// const grabAllAdjacentCells = ( // <!------------------ grabAllAdjacentCells()\n//   cells: Cell[][], rowParam: number, colParam: number\n// ): { // types of the outputs\n//   topLeftCell: Cell | null;\n//   topCell: Cell | null;\n//   topRightCell: Cell | null;\n//   leftCell: Cell | null;\n//   rightCell: Cell | null;\n//   bottomLeftCell: Cell | null;\n//   bottomCell: Cell | null;\n//   bottomRightCell: Cell | null;\n// } => {\n//   const topLeftCell = rowParam>0 && colParam>0 ? cells[rowParam-1][colParam-1] : null;\n//   const topCell = rowParam > 0 ? cells[rowParam-1][colParam] : null;\n//   const topRightCell = rowParam>0 && colParam<MAX_COLS-1 ? cells[rowParam-1][colParam+1] : null;\n//   const leftCell = colParam > 0 ? cells[rowParam][colParam-1] : null;\n//   const rightCell = colParam < MAX_COLS -1 ? cells[rowParam][colParam+1] : null;\n//   const bottomLeftCell = rowParam<MAX_ROWS-1 && colParam>0 ? cells[rowParam+1][colParam-1] : null;\n//   const bottomCell = rowParam<MAX_ROWS-1 ? cells[rowParam+1][colParam] : null;\n//   const bottomRightCell = rowParam<MAX_ROWS-1 && colParam<MAX_COLS-1 ?cells[rowParam+1][colParam+1] : null;\n\n//   return {\n//     topLeftCell,\n//     topCell,\n//     topRightCell,\n//     leftCell,\n//     rightCell,\n//     bottomLeftCell,\n//     bottomCell,\n//     bottomRightCell\n//   }\n// };  // <!---------------------------------- close ------ grabAllAdjacentCells()\n\n// export const generateCells = (): Cell[][] => {\n//     let cells: Cell[][] = [];\n  \n//     // generating all cells\n//     for (let row = 0; row < MAX_ROWS; row++) {\n//       cells.push([]);\n//       for (let col = 0; col < MAX_COLS; col++) {\n//         cells[row].push({\n//           value: CellValue.none,\n//           state: CellState.open\n//         });\n//       }\n//     }\n\n//   // randomly put 10 bombs\n//   let bombsPlaced = 0;\n//   while (bombsPlaced < NO_OF_BOMBS) {\n//     const randomRow = Math.floor(Math.random() * MAX_ROWS);\n//     const randomCol = Math.floor(Math.random() * MAX_COLS);\n\n//     const currentCell = cells[randomRow][randomCol];\n//     if (currentCell.value !== CellValue.bomb) {\n//       cells = cells.map((row, rowIndex) =>\n//         row.map((cell, colIndex) => {\n//           if (randomRow === rowIndex && randomCol === colIndex) {\n//             return {\n//               ...cell,\n//               value: CellValue.bomb\n//             };\n//           }\n//           return cell;\n//         })\n//       );\n//       bombsPlaced++;\n//     } // if statement\n//   } // while loop\n\n//   // calculate the numerals that correspond w/cells adjacent to bombs\n//   for (let rowIndex=0; rowIndex<MAX_ROWS; rowIndex++) {\n//     for (let colIndex=0; colIndex<MAX_COLS; colIndex++) {\n//         const currentCell = cells[rowIndex][colIndex];\n//         if (currentCell.value === CellValue.bomb) {\n//             continue;\n//         }\n//         let numberOfBombs = 0;\n\n//         const {\n//           topLeftCell,\n//           topCell,\n//           topRightCell,\n//           leftCell,\n//           rightCell,\n//           bottomLeftCell,\n//           bottomCell,\n//           bottomRightCell\n//         } = grabAllAdjacentCells(cells, rowIndex, colIndex);\n\n//         // const topLeftCell = rowIndex>0 && colIndex>0 ? cells[rowIndex-1][colIndex-1] : null;\n//         // const topCell = rowIndex > 0 ? cells[rowIndex-1][colIndex] : null;\n//         // const topRightCell = rowIndex>0 && colIndex<MAX_COLS-1 ? cells[rowIndex-1][colIndex+1] : null;\n//         // const leftCell = colIndex > 0 ? cells[rowIndex][colIndex-1] : null;\n//         // const rightCell = colIndex < MAX_COLS -1 ? cells[rowIndex][colIndex+1] : null;\n//         // const bottomLeftCell = rowIndex<MAX_ROWS-1 && colIndex>0 ? cells[rowIndex+1][colIndex-1] : null;\n//         // const bottomCell = rowIndex<MAX_ROWS-1 ? cells[rowIndex+1][colIndex] : null;\n//         // const bottomRightCell = rowIndex<MAX_ROWS-1 && colIndex<MAX_COLS-1 ?cells[rowIndex+1][colIndex+1] : null;\n\n//         if (topLeftCell && topLeftCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (topCell && topCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (topRightCell && topRightCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (leftCell && leftCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (rightCell && rightCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (bottomLeftCell && bottomLeftCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (bottomCell && bottomCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (bottomRightCell && bottomRightCell.value === CellValue.bomb) {\n//             numberOfBombs++;\n//         }\n//         if (numberOfBombs > 0) {\n//             cells[rowIndex][colIndex] = {\n//                 ...currentCell,\n//                 value: numberOfBombs\n//             }\n//         }\n\n//     } // inner for-loop\n//   } // outer for-loop\n\n//     return cells;\n// }; // <!-------------------------------------- close ------- generateCells()\n\n// export const openMultipleCells = ( // <!----------------- openMultipleCells()\n//   cells: Cell[][], \n//   rowParam: number, \n//   colParam: number\n// ): Cell[][] => {\n//   const currentCell = cells[rowParam][colParam];\n\n//   if (\n//     currentCell.state === CellState.visible || \n//     currentCell.state === CellState.flagged\n//   ) {\n//       return cells;\n//   }\n  \n//   let newCells = cells.slice();\n\n//   newCells[rowParam][colParam].state = CellState.visible;\n//   const {\n//     topLeftCell,\n//     topCell,\n//     topRightCell,\n//     leftCell,\n//     rightCell,\n//     bottomLeftCell,\n//     bottomCell,\n//     bottomRightCell\n//   } = grabAllAdjacentCells(cells, rowParam, colParam);\n  \n//   if (topLeftCell && topLeftCell.state !== CellState.open &&\n//      topLeftCell.value !== CellValue.bomb) {\n//       if (topLeftCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam-1, colParam-1);\n//       } else {\n//         newCells[rowParam-1][colParam-1].state = CellState.visible;\n//       }\n//   } // outer if-statement for topLeftCell\n//   if (topCell && topCell.state !== CellState.open &&\n//     topCell.value !== CellValue.bomb) {\n//       if (topCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam-1, colParam);\n//       } else {\n//         newCells[rowParam-1][colParam].state = CellState.visible;\n//       }\n//   } // outer if-statement for topCell\n//   if (topRightCell && topRightCell.state !== CellState.open &&\n//     topRightCell.value !== CellValue.bomb) {\n//       if (topRightCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam-1, colParam+1);\n//       } else {\n//         newCells[rowParam-1][colParam+1].state = CellState.visible;\n//       }\n//   } // outer if-statement for topRightCell\n//   if (leftCell && leftCell.state !== CellState.open &&\n//     leftCell.value !== CellValue.bomb) {\n//       if (leftCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam, colParam-1);\n//       } else {\n//         newCells[rowParam][colParam-1].state = CellState.visible;\n//       }\n//   } // outer if-statement for leftCell\n//   if (rightCell && rightCell.state !== CellState.open &&\n//     rightCell.value !== CellValue.bomb) {\n//       if (rightCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam, colParam+1);\n//       } else {\n//         newCells[rowParam][colParam+1].state = CellState.visible;\n//       }\n//   } // outer if-statement for rightCell\n//   if (bottomLeftCell && bottomLeftCell.state !== CellState.open &&\n//       bottomLeftCell.value !== CellValue.bomb) {\n//       if (bottomLeftCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam+1, colParam-1);\n//       } else {\n//         newCells[rowParam+1][colParam-1].state = CellState.visible;\n//       }\n//   } // outer if-statement for bottomLeftCell\n//   if (bottomCell && bottomCell.state !== CellState.open &&\n//     bottomCell.value !== CellValue.bomb) {\n//       if (bottomCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam+1, colParam);\n//       } else {\n//         newCells[rowParam+1][colParam].state = CellState.visible;\n//       }\n//   } // outer if-statement for bottomCell\n//   if (bottomRightCell && bottomRightCell.state !== CellState.open &&\n//     bottomRightCell.value !== CellValue.bomb) {\n//       if (bottomRightCell.value === CellValue.none) {\n//         newCells = openMultipleCells(newCells, rowParam+1, colParam+1);\n//       } else {\n//         newCells[rowParam+1][colParam+1].state = CellState.visible;\n//       }\n//   } // outer if-statement for bottomRightCell\n//   return newCells;\n\n// }; // <!---------------------------------- close ------- openMultipleCells()"],"mappings":"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ACK,KAAK,KAAKjB,SAAS,CAAC4B,IAAI,EACxC;IACA,IAAIhB,eAAe,CAACK,KAAK,KAAKjB,SAAS,CAACkB,IAAI,EAAE;MAC5CmB,QAAQ,GAAGH,iBAAiB,CAACG,QAAQ,EAAElC,QAAQ,GAAG,CAAC,EAAEC,QAAQ,GAAG,CAAC,CAAC;IACpE,CAAC,MAAM;MACLiC,QAAQ,CAAClC,QAAQ,GAAG,CAAC,CAAC,CAACC,QAAQ,GAAG,CAAC,CAAC,CAACe,KAAK,GAAGpB,SAAS,CAACoC,OAAO;IAChE;EACF;EAEA,OAAOE,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}