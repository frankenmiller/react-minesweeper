{"ast":null,"code":"import { MAX_ROWS, MAX_COLS, NO_OF_BOMBS } from \"../constants\";\nimport { CellValue, CellState } from \"../types\";\nexport const GenerateCells = () => {\n  const cells = [];\n  for (let row = 0; row < MAX_ROWS; row++) {\n    cells.push([]);\n    for (let col = 0; col < MAX_COLS; col++) {\n      cells[row].push({\n        value: CellValue.none,\n        state: CellState.open\n      });\n    }\n  }\n  let bombsPlaced = 0;\n  while (bombsPlaced < NO_OF_BOMBS) {\n    const randomRow = Math.floor(Math.random() * MAX_ROWS);\n    const randomCol = Math.floor(Math.random() * MAX_COLS);\n    const currentCell = cells[randomRow][randomCol];\n    if (currentCell.value !== CellValue.bomb) {\n      cells = cells.map((row, rowIndex) => row.map((cell, colIndex) => {\n        if (randomRow === rowIndex && randomCol === colIndex) {\n          return {\n            ...cell,\n            value: CellValue.bomb\n          };\n        }\n        return cell;\n      }));\n    }\n  }\n  return cells;\n};\n_c = GenerateCells;\nvar _c;\n$RefreshReg$(_c, \"GenerateCells\");","map":{"version":3,"names":["MAX_ROWS","MAX_COLS","NO_OF_BOMBS","CellValue","CellState","GenerateCells","cells","row","push","col","value","none","state","open","bombsPlaced","randomRow","Math","floor","random","randomCol","currentCell","bomb","map","rowIndex","cell","colIndex"],"sources":["/Users/dr_frankenmiller/Projects/react-minesweeper/src/utils/index.ts"],"sourcesContent":["import { MAX_ROWS, MAX_COLS, NO_OF_BOMBS } from \"../constants\";\nimport { CellValue, CellState, Cell } from \"../types\";\n\nexport const GenerateCells = (): Cell[][] => {\n    const cells: Cell[][] = [];\n\n    for (let row=0; row<MAX_ROWS; row++) {\n        cells.push([]);\n        for (let col=0; col<MAX_COLS; col++) {\n            cells[row].push({\n                value: CellValue.none,\n                state: CellState.open\n            });\n        }\n    }\n\n    let bombsPlaced = 0;\n    while (bombsPlaced < NO_OF_BOMBS) {\n        const randomRow = Math.floor(Math.random() * MAX_ROWS);\n        const randomCol = Math.floor(Math.random() * MAX_COLS);\n\n        const currentCell = cells[randomRow][randomCol];\n        if (currentCell.value !== CellValue.bomb) {\n            cells = cells.map((row, rowIndex) => \n                row.map((cell, colIndex) => {\n                if (randomRow === rowIndex && randomCol === colIndex) {\n                    return {\n                        ...cell,\n                        value: CellValue.bomb\n                    }\n                }\n                return cell;\n            }))\n        }\n    }\n\n    return cells;\n};"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,QAAQ,EAAEC,WAAW,QAAQ,cAAc;AAC9D,SAASC,SAAS,EAAEC,SAAS,QAAc,UAAU;AAErD,OAAO,MAAMC,aAAa,GAAG,MAAgB;EACzC,MAAMC,KAAe,GAAG,EAAE;EAE1B,KAAK,IAAIC,GAAG,GAAC,CAAC,EAAEA,GAAG,GAACP,QAAQ,EAAEO,GAAG,EAAE,EAAE;IACjCD,KAAK,CAACE,IAAI,CAAC,EAAE,CAAC;IACd,KAAK,IAAIC,GAAG,GAAC,CAAC,EAAEA,GAAG,GAACR,QAAQ,EAAEQ,GAAG,EAAE,EAAE;MACjCH,KAAK,CAACC,GAAG,CAAC,CAACC,IAAI,CAAC;QACZE,KAAK,EAAEP,SAAS,CAACQ,IAAI;QACrBC,KAAK,EAAER,SAAS,CAACS;MACrB,CAAC,CAAC;IACN;EACJ;EAEA,IAAIC,WAAW,GAAG,CAAC;EACnB,OAAOA,WAAW,GAAGZ,WAAW,EAAE;IAC9B,MAAMa,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,GAAGlB,QAAQ,CAAC;IACtD,MAAMmB,SAAS,GAAGH,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,GAAGjB,QAAQ,CAAC;IAEtD,MAAMmB,WAAW,GAAGd,KAAK,CAACS,SAAS,CAAC,CAACI,SAAS,CAAC;IAC/C,IAAIC,WAAW,CAACV,KAAK,KAAKP,SAAS,CAACkB,IAAI,EAAE;MACtCf,KAAK,GAAGA,KAAK,CAACgB,GAAG,CAAC,CAACf,GAAG,EAAEgB,QAAQ,KAC5BhB,GAAG,CAACe,GAAG,CAAC,CAACE,IAAI,EAAEC,QAAQ,KAAK;QAC5B,IAAIV,SAAS,KAAKQ,QAAQ,IAAIJ,SAAS,KAAKM,QAAQ,EAAE;UAClD,OAAO;YACH,GAAGD,IAAI;YACPd,KAAK,EAAEP,SAAS,CAACkB;UACrB,CAAC;QACL;QACA,OAAOG,IAAI;MACf,CAAC,CAAC,CAAC;IACP;EACJ;EAEA,OAAOlB,KAAK;AAChB,CAAC;AAAC,KAlCWD,aAAa;AAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}